#This is an example of how TTB-ABC's density converges to the right tree
#Copyright@Schulz, Speekenbrink, Meder
#Recovering a tree structure that has been created by standard TTB
#This script demonstrates that TTB-ABC can find trees generated by TTB

#Input for TTB-ABC: 
##4 trinary x variables: x_1,...,x_4 p(x_i=1)=p(x_i=-1)=1/4, p(x_i=0)=0.5
##1 binary y variable: y=TTB(x1,x2,x3) with c1>c2>c3, x4 is unimportant

#Result of script:
##A plot of the density over trees after 1,10,50, and 100 simulations

#House keeping
rm(list=ls())

#Load ttbabc-sources
source("R/ttbabcfit.R")

#Load packages
packages <- c('plyr', 'ggplot2', 'scales', 'diagram')
lapply(packages, library, character.only=TRUE)

#My Take The Best-Function
myttb<-function(x){
  y<-0
  for (i in seq_along(x)){
    y<-ifelse(y==0 & x[i]!=0,x[i],y)
  }
  y<-ifelse(y==0,sample(c(-1,1),1),y)
  return(y)
}

#Quick and dirty function to draw a tree, given a proposal depth
##Take in the depth, resulted from a polya-draw
drawtreelines<-function(depthorder){
  #curvy effect for lines
  curvy<-runif(1,-0.1,0.1)
  #line vector
  lined<-data.frame(c(2.5, depthorder[1], 2.5, depthorder[2], 2.5, depthorder[3], 2.5, depthorder[4], 2.5),
                    c(5,4,3.5,3,2.5,2,1.5,1,0))
  #loop over line vector
  for (p in 2:nrow(lined)){
    #draw a curve, adjust alpha transperancy
    curvedarrow(from=c(lined[p-1,1], lined[p-1,2]),   to= c(lined[p,1], lined[p,2]), curve = curvy, arr.pos = 1, lwd=0.5, lcol=alpha("blue", 0.2), arr.width=0, arr.length=0)
    }
}

#Create X-frame
##X-values
xttb<-data.frame(apply(matrix(NA, nrow=1000, ncol=4), 2, function(x){ sample(c(-1,0,0,1), 1000, replace = TRUE)}))
##Create y-frame, with x_4 unimportant
yttb<-apply(xttb[,1:3],1,myttb)

#Simulations for 1,10,50, and 100
numberofsims<-c(1, 10, 50, 100)
#save outcome to pdf device
pdf("figs/treedenisty.pdf", width=10, height=5)
#adjust device
par(oma=c(0,0,2,0))
par(mfrow=c(1,4))
#loop over number of simulations
for (k in seq_along(numberofsims)){
  #all points
  points<-expand.grid(1:4, 1:4)
  #empty plot
  plot(points, xlab="Cue", ylab="Depth", main=paste0("Tree density: N=", numberofsims[k]),
       xlim=c(0,5), ylim=c(0,5), pch=19, cex=1.5, xaxt="n", yaxt="n")
  #axis marking the cues
  axis(1, 1:4, paste0("C", 1:4))
  #axis marking the depth
  axis(2, 1:4, paste0("D", 4:1))
  
  #we'll estimate TTB-ABC 5 times for each nsims
  for (l in 1:10){
    
    #fit TTB-ABC, we bump up epsilon a little for graphical purposes
    m<-ttbabcfit(xttb, yttb, epsilon=0.92, nsims=numberofsims[k])
    #probability of cue to be chosen as posterior of a beta distribution
    if (k>1){
      pchoice<-apply(cbind(m$m$ballcounts, m$trials), 1, function(x){rbeta(1, 0.5+x[1], 0.5+x[2]-x[1])})
    }
    else{
      pchoice<-c(0.5,0.5,0.5,0.5)
    }
    #select a randomly drawn cue order in dependency of the tree position probability
    select<-apply(matrix(NA, ncol=10), 2, function(x) sample(1:ncol(xttb),ncol(xttb),prob=pchoice/sum(pchoice), repl=FALSE))
    #draw 10 proposal trees
    apply(select,2, function(x)drawtreelines(c(x[1],x[2],x[3],x[4])))
  }
  #draw the points over the lines, cause that looks better
  points(c(2.5, 2.5, 2.5, 2.5, 2.5), c(5,3.5,2.5,1.5, 0), col="red",pch=15, cex=1.5)
  #as well as the nodes
  points(points, pch=19, cex=1.5)
}
#add a title
title("Density over trees", outer=TRUE, cex=2)
#close pdf-device
dev.off()
#END