#This is a function to generate predictions with TTB-ABC
#Copyright@Schulz, Speekenbrink & Meder
#ttbabcpredict:: (data frame generated by ttbabcfit, data frame to generate predictions for)->data frame of predictions
#ttbabc:: (list(data.frame, data.frame, data.frame), vector, numeric)->data.frame

#INPUT:
#M:  A list that contains the polya data.frame that has been generated by ttbabcfit
#XX: A matrix or frame of locations for new predictions

#OUTPUT
##A data frame containing prob, class, and se
###prob:  probabilities of bbeing a win p(y_i=1)
###class: predicted class of new XX-location, i.e. -1 or 1
###se:    standard error of the prediction

ttbabcpredict<-function(polya, XX, aggnumb=100){
  
  trials<-polya$trials
  polyacue<-polya$m
  #Firt, perform some checks
  #is m of type TTB-ABC?
  if (sum(names(polyacue)==c("balls","ballcounts","wsucc","wtrials"))!=4){stop("m is not a ttbfit-generated data frame. Please recheck input.")}
  #Does XX have the right inputs
  if (sum(XX!=-1 & XX!=0 & XX!=1)>0){stop("Wrong XX-input. XX-values have to be {-1,0,1}.")}
  #Do the dimensions match?
  if (max(polyacue$balls) != ncol(XX)) {stop("The number of variables in XX is not the same as in the frame you used for fitting.")}
  #Is aggnumb numeric and bigger than 0?
  if (!is.numeric(aggnumb) || aggnumb<=0) {stop("Wrong input for aggnumb. Number of aggregations has to be numeric and bigger than 0.")}
  
  #initialize prediction matrix
  ypred<-matrix(0, ncol=aggnumb, nrow=nrow(XX))
  #cases of cues
  cases<-max(polyacue$balls)
      #aggregation over aggnumb simulations
      for (j in 1:aggnumb){    #creat probability of tree position by Beta-Binomial-posterior process
        pchoice<-apply(cbind(polyacue$ballcounts, trials), 1, function(x){rbeta(1, 0.5+x[1], 0.5+x[2]-x[1])})
        #select a randomly drawn cue order in dependency of the tree position probability
        select<-sample(1:cases,cases,prob=pchoice/sum(pchoice), repl=FALSE)
        #create a dummy urn
        polyasub<-polyacue[select,]
        #create a proposal tree
        ttbprop<-data.frame(cue=polyasub$balls)
        #create weight probabilities by posterior beta-binomial process
        pweights<-apply(cbind(polyasub$wsucc, polyasub$wtrials), 1, function(x){rbeta(1, 0.5+x[1], 0.5+x[2]-x[1])})
        #create proposal weights in dependency of the weight balls
        ttbprop$w<-ifelse(rbinom(nrow(ttbprop),1, prob=pweights/sum(pweights))==0,-1,1)
        yprop<-rep(0, nrow(XX))
        #start loop for aggregations  
        for (i in 1:(nrow(ttbprop))){
          #generate prediction for i-th aggregation
          yprop<-ifelse(yprop==0,ttbprop$w[i]*XX[,ttbprop$cue[i]],yprop)
          }
    #guess if still 0
    yprop<-ifelse(yprop==0,ifelse(rbinom(1,1,0.5)==0,-1,1),yprop)
    #add to predictive matrix
    ypred[,j]<- -yprop
      }
  #create output data frame:
  dpred<-data.frame(
    #probabilities of p(y_i=1)
    prob=(apply(ypred,1,mean)+1)/2,
    #predicted class, i.e. most likely win or loss
    class=ifelse(apply(ypred,1,mean)>0,1,-1), 
    #standard error of prediction (assymptotically)
    se=apply((ypred+1)/2,1,sd))
#return the prediction frame
return(dpred)
}
#END